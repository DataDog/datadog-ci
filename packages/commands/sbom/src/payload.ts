import * as console from 'console'
import crypto from 'crypto'

import {SpanTags} from '../../helpers/interfaces'
import {
  GIT_BRANCH,
  GIT_COMMIT_AUTHOR_EMAIL,
  GIT_COMMIT_AUTHOR_NAME,
  GIT_COMMIT_COMMITTER_EMAIL,
  GIT_COMMIT_COMMITTER_NAME,
  GIT_REPOSITORY_URL,
  GIT_SHA,
  SBOM_TOOL_GENERATOR_NAME,
  SBOM_TOOL_GENERATOR_VERSION,
} from '../../helpers/tags'

import {
  EXCLUSION_KEY,
  FILE_PACKAGE_PROPERTY_KEY,
  IS_DEPENDENCY_DEV_ENVIRONMENT_PROPERTY_KEY,
  IS_DEPENDENCY_DIRECT_PROPERTY_KEY,
  PACKAGE_MANAGER_PROPERTY_KEY,
  REACHABLE_SYMBOL_LOCATION_KEY_PREFIX,
} from './constants'
import {getLanguageFromComponent} from './language'
import {
  Relations,
  Dependency,
  File,
  Location,
  LocationFromFile,
  Locations,
  ScaRequest,
  GenerationTool,
  Property,
  ReachableSymbolLocationValue,
  Affect,
  Vulnerability,
} from './types'

// Parse a location from the file generated by osv-scanner into a location that can be
// sent to our API.
const parseLocation = (location: LocationFromFile): undefined | Location => {
  if (!location) {
    return undefined
  }
  if (
    !location.file_name ||
    !location.line_start ||
    !location.line_end ||
    !location.column_start ||
    !location.column_end
  ) {
    return undefined
  }

  if (location.line_end < location.line_start) {
    return undefined
  }

  if (location.line_end === location.line_start && location.column_end <= location.column_start) {
    return undefined
  }

  // check location values
  if (location.line_start <= 0 || location.line_end <= 0 || location.column_start <= 0 || location.column_end <= 0) {
    return undefined
  }

  return {
    file_name: location.file_name,
    start: {
      line: location.line_start,
      col: location.column_start,
    },
    end: {
      line: location.line_end,
      col: location.column_end,
    },
  }
}

// Parse all locations from the OSV scanner. If one fails to be parse, it's set to undefined
const parseLocationsString = (locations: string): undefined | Locations => {
  try {
    const parsed = JSON.parse(locations)

    const res: Locations = {
      block: parseLocation(parsed['block']),
      namespace: parseLocation(parsed['namespace']),
      name: parseLocation(parsed['name']),
      version: parseLocation(parsed['version']),
    }

    // if block is not defined, the API fails and we should rather ignore the payload
    if (!res.block) {
      return undefined
    }

    return res
  } catch (e) {
    console.error(`error when parsing locations: ${e}`)
  }

  return undefined
}

// Generate the payload we send to the API
// jsonContent is the SBOM file content read from disk
// tags are the list of tags we retrieved
export const generatePayload = (
  jsonContent: any,
  tags: SpanTags,
  service: string,
  env: string
): ScaRequest | undefined => {
  const dependencies: Dependency[] = []
  const files: File[] = []
  const relations: Relations[] = []
  const vulnerabilities: Vulnerability[] = []

  if (jsonContent) {
    // If the tool generator for SBOM creation is not already defined by the user,
    // attempt to determine it from the metadata attribute.
    if (!tags[SBOM_TOOL_GENERATOR_NAME]) {
      const generationTool = getGenerationTool(jsonContent)

      if (generationTool) {
        tags[SBOM_TOOL_GENERATOR_NAME] = generationTool.name
        tags[SBOM_TOOL_GENERATOR_VERSION] = generationTool.version
      }
    }
    if (jsonContent['components']) {
      for (const component of jsonContent['components']) {
        if (!component['type'] || !component['name']) {
          continue
        }

        if (component['type'] === 'library' || component['type'] === 'framework') {
          const dependency = extractingDependency(component)

          if (dependency !== undefined) {
            dependencies.push(dependency)
          }
        } else if (component['type'] === 'file') {
          files.push(extractingFile(component))
        }
      }
    }
    if (jsonContent['dependencies']) {
      for (const dependency of jsonContent['dependencies']) {
        if (!dependency['ref'] || !dependency['dependsOn']) {
          continue
        }
        relations.push(extractingRelations(dependency))
      }
    }
    if (jsonContent['vulnerabilities']) {
      for (const vulnerability of jsonContent['vulnerabilities']) {
        if (!vulnerability['id'] || !vulnerability['bom-ref']) {
          continue
        }
        const affects: Affect[] = []
        // Iterate over the affects of the vulnerability when it exists
        if (vulnerability['affects']) {
          for (const affected of vulnerability['affects']) {
            if (!affected['ref']) {
              continue
            }
            affects.push({
              ref: affected['ref'],
            })
          }
        }
        vulnerabilities.push({
          id: vulnerability['id'],
          bom_ref: vulnerability['bom-ref'],
          affects,
        })
      }
    }
  }

  // The tags dictionary is validated prior to generatePayload being called
  //  see upload.ts missingGitFields
  return {
    id: crypto.randomUUID(),
    commit: {
      author_name: tags[GIT_COMMIT_AUTHOR_NAME] ?? '',
      author_email: tags[GIT_COMMIT_AUTHOR_EMAIL] ?? '',
      committer_name: tags[GIT_COMMIT_COMMITTER_NAME] ?? '',
      committer_email: tags[GIT_COMMIT_COMMITTER_EMAIL] ?? '',
      sha: tags[GIT_SHA] ?? '',
      branch: tags[GIT_BRANCH] ?? '',
    },
    repository: {
      url: tags[GIT_REPOSITORY_URL] ?? '',
    },
    tags,
    dependencies,
    files,
    relations,
    vulnerabilities,
    service,
    env,
  }
}

const extractingDependency = (component: any): Dependency | undefined => {
  const lang = getLanguageFromComponent(component)

  if (!lang) {
    return
  }

  const purl: string | undefined = component['purl']

  if (!purl) {
    console.error(`cannot find purl for component ${component['name']}`)

    return
  }

  const locations: Locations[] = []

  // Extract the unique location strings from the file.
  const locationsStrings: Set<string> = new Set()
  if (component['evidence'] && component['evidence']['occurrences']) {
    for (const occ of component['evidence']['occurrences']) {
      if (occ['location']) {
        const loc: string = occ['location']

        if (!locationsStrings.has(loc)) {
          locationsStrings.add(loc)
        }
      }
    }
  }

  for (const l of locationsStrings) {
    const loc = parseLocationsString(l)
    if (loc) {
      locations.push(loc)
    }
  }

  let packageManager = ''
  let isDirect
  let isDev
  const exclusions: string[] = []
  const reachableSymbolProperties: Property[] = []
  for (const property of component['properties'] ?? []) {
    if (property['name'] === PACKAGE_MANAGER_PROPERTY_KEY) {
      packageManager = property['value']
    } else if (property['name'] === IS_DEPENDENCY_DIRECT_PROPERTY_KEY) {
      isDirect = property['value'].toLowerCase() === 'true' ? true : undefined
    } else if (property['name'] === IS_DEPENDENCY_DEV_ENVIRONMENT_PROPERTY_KEY) {
      isDev = property['value'].toLowerCase() === 'true' ? true : undefined
    } else if (property['name'] === EXCLUSION_KEY) {
      exclusions.push(property['value'])
    } else if (property['name'].startsWith(REACHABLE_SYMBOL_LOCATION_KEY_PREFIX)) {
      const missingKeys = validateReachableSymbolLocationValue(property['value'])
      if (missingKeys.length > 0) {
        console.error(`Error in reachable symbol locations for ${purl}:`)
        for (const key of missingKeys) {
          console.error(`- ${key} is missing`)
        }
        continue
      }
      reachableSymbolProperties.push({
        name: property['name'],
        value: property['value'],
      })
    }
  }

  const dependency: Dependency = {
    name: component['name'],
    group: component['group'] || undefined,
    version: component['version'] || undefined,
    language: lang,
    licenses: [],
    purl,
    locations,
    is_direct: isDirect,
    is_dev: isDev,
    package_manager: packageManager,
    reachable_symbol_properties: reachableSymbolProperties,
    exclusions,
  }

  return dependency
}

const extractingFile = (component: any): File => {
  let purl
  for (const property of component['properties'] ?? []) {
    if (property['name'] === FILE_PACKAGE_PROPERTY_KEY) {
      purl = property['value']
    }
  }

  return {
    name: component['name'],
    purl,
  }
}

const extractingRelations = (dependency: any): Relations => {
  return {
    component_ref: dependency['ref'],
    depends_on: dependency['dependsOn'],
  }
}

const getGenerationTool = (jsonContent: any): GenerationTool | undefined => {
  const tools = jsonContent?.metadata?.tools

  // CycloneDX 1.4 defines tools as an array:
  // https://cyclonedx.org/docs/1.4/json/#metadata_tools
  if (Array.isArray(tools)) {
    return extractGenerationTool(tools[0])
    // CycloneDX > 1.5 defines tools as an object
    // https://cyclonedx.org/docs/1.5/json/#metadata_tools
  } else if (typeof tools === 'object') {
    const preferredTool = findPreferredTool(tools)

    return extractGenerationTool(preferredTool)
  }

  return undefined
}

const findPreferredTool = (tool: any): any => {
  if (tool.components && Array.isArray(tool.components)) {
    // Prefer components of type 'application', as from experience,
    // that's where sbom generators report their name.
    const applicationComponent = tool.components.find((component: any) => component.type === 'application')
    if (applicationComponent) {
      return applicationComponent
    }

    // If no application component, return the first component
    return tool.components[0]
  }

  return tool
}

const extractGenerationTool = (tool: any): GenerationTool => {
  return {
    name: tool['name'],
    version: tool['version'],
  }
}

// validateReachableSymbolLocationValue checks if the JSON string value in
// the reachable symbol location is valid and returns any keys that were missing.
const validateReachableSymbolLocationValue = (value: string): string[] => {
  const missingKeys = []

  const parsedVals: ReachableSymbolLocationValue[] = JSON.parse(value)

  for (const parsedVal of parsedVals) {
    if (!parsedVal.file_name) {
      missingKeys.push('file_name')
    }
    if (!parsedVal.line_start) {
      missingKeys.push('line_start')
    }
    if (!parsedVal.line_end) {
      missingKeys.push('line_end')
    }
    if (!parsedVal.column_start) {
      missingKeys.push('column_start')
    }
    if (!parsedVal.column_end) {
      missingKeys.push('column_end')
    }
    if (!parsedVal.symbol) {
      missingKeys.push('symbol')
    }
  }

  return missingKeys
}
